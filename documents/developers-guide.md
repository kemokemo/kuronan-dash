# 黒菜んダッシュ Developers Guide

## 前提条件

- golang Ver. 1.9 以降

## 実行方法

リビジョン情報を渡しながら起動してみましょう。

```sh
go run -ldflags="-X 'main.Revision=$(git rev-parse --short HEAD)'" *.go
```

## ビルド方法

### 通常ビルド

タイトル画面にリビジョン情報を含むバージョン情報を表示していますので、以下のようにビルドします。

```sh
go build -ldflags="-X 'main.Revision=$(git rev-parse --short HEAD)'"
```

### WebAssembly

`WebAssembly`形式へとビルドして、ブラウザで遊ぶこともできます。以下のようにビルドます。

```sh
GOOS=js GOARCH=wasm go build -ldflags="-X 'main.Revision=$(git rev-parse --short HEAD)'" -o public/kuronan-dash.wasm
```

あとは、`public`フォルダをブラウザで閲覧可能にすれば、ブラウザでゲームをプレイできます。Dockerコンテナの`nginx`でも良いですし、拙作の[miniweb](https://github.com/kemokemo/miniweb)などの小さなWebサービスでも良いです。

```sh
miniweb -p 9000 public
```

上記を実行した場合、ブラウザで `http://localhost:9000/` を開きましょう。

### Mobile

スマホにデプロイして遊んでみる場合は、[gomobile](https://github.com/golang/mobile)を使うのが便利です。[公式の手順](https://github.com/golang/go/wiki/Mobile)を見ながらインストールします。

[Android端末へのインストール](https://github.com/golang/go/wiki/Mobile#building-and-deploying-to-android)は比較的簡単で、PCからアプリをインストール可能な状態にした端末をPCに接続し、以下を実行します。

```sh
gomobile install github.com/kemokemo/kuronan-dash
```

## 設計メモ

### ポインタの多用について

非常に低スペックな環境でも動作することを想定しているため、極力ローカル変数を作らない設計にしています。特に、`ebiten.Game`の`Update`関数で呼び出される処理はゲームプレイ中に非常に多くの回数呼び出される処理のため、実装のしやすさを犠牲にしてもポインタで保持して管理しながら使うという方針にしています。

### goroutine

音声再生の処理などキャラクターのステータスに応じた処理の一部で、`state`の伝搬に`goroutine`および`channel`を使っています。

### ゲームステージ

`scenes`パッケージの`scene`インターフェイスを実装することで、新しいゲーム内の画面やステージを追加可能です。後述するように、フィールドは`Field`インターフェイスの実装を、障害物は`Obstacle`インターフェイスの実装、食べ物は`Food`インターフェイスの実装をそれぞれ保持しておいて、`scene`インターフェイスの`Update`や`Draw`実装の中で画面の構成要素それぞれに`Update`や`Draw`を実装することで画面を実現できます。

### Field

`field`パッケージの`Field`インターフェイスを満たす構造体を作ることで、ステージ毎に異なる雰囲気のフィールドを描画できるようにしています。ステージ1の草原フィールドとして実装した`PrairieField`などです。

また、フィールド上に配置する障害物やアイテムなど、「レーン上に配置して、キャラクターの動きに応じて位置を変える必要がある物体」については`ScrollableObject`インターフェイスを満たすような構造体にします。さらに、キャラクターが食べてスタミナを回復させる食べ物にする場合は`Food`インターフェイスを、岩などのようにキャラクターの進行を妨げる障害物にする場合は`Obstacle`インターフェイスを、それぞれ実装することで実現可能です。

### キャラクター

ゲーム画面に描画するキャラクターは、`character`パッケージの`Player`構造体で実現しています。キャラクター選択画面での選択情報を元に、ゲーム画面で用いるキャラクターの実体が変わります。ここはインターフェイスにしておらず、`Player`構造体が保持する画像や音声データなどを変えて作り分けることでキャラクターを作り分けています。

### StateMachine

また、同じ`move`パッケージの`StateMachine`構造体は、ユーザーからのインプット情報や上・中・下段のレーン間移動のための状態管理を行う構造体です。レーン間の移動で過去に何度か不具合を出しながらやや複雑な実装にしてしまったので、これを`Player`構造体から切り離してその名の通りステートマシンとして動作させることを意図して切り離したのが発端です。

### InputChecker

画面毎にボタン・マウス・タッチによる操作とそれの意味を変えるため、`input`パッケージの`InputChecker`インターフェイスを画面毎に実装する仕組みにしています。画面で使うボタンを予め保登録しておくことで、「このボタンが押されたら、こうげき操作がトリガーされたとみなす」という処理を全て`InputChecker`の実装構造体が行い、ユーザー操作を知りたい他の実装では単にトリガーの有無を`bool`値でもらうだけでよくなります。

### VelocityController

各キャラクターの動きを制御する仕組みに、`move`パッケージの`VelocityController`というインターフェイスを使っています。このインターフェイスを実装した構造体をキャラクター毎に実装して、それぞれキャラクター毎に動きをカスタマイズしています。「このキャラは、この状態の時だけちょっと特殊な動きをする」というような仕様にしたくなった時にも、他のキャラに影響を与えず変更できるようにするためです。

また、このゲームは強制スクロールアクションなので、画面上でのキャラクターの描画位置は変えずに、キャラクターの進行速度に応じてそれのマイナス速度をフィールドの各パーツに適用して描画する仕組みを採用しています。
